{
  "version": 3,
  "sources": ["../src/overload.js"],
  "sourcesContent": ["/**\r\n * \u7C7B\u578B\u540D\u79F0\u6620\u5C04\u8868\r\n * @type {Map<String, String>}\r\n */\r\nconst TYPE_NAMES = new Map([\r\n  [\"number\", \"Number\"],\r\n  [\"string\", \"String\"],\r\n  [\"boolean\", \"Boolean\"],\r\n  [\"symbol\", \"Symbol\"],\r\n  [\"bigint\", \"BigInt\"],\r\n  [\"undefined\", \"(undefined)\"],\r\n]);\r\n\r\n/**\r\n * \u5339\u914D\u7C7B\u578B\r\n * @param {any} param - \u4F20\u5165\u7684\u53C2\u6570\r\n * @param {any} type - \u671F\u671B\u7684\u7C7B\u578B\r\n * @returns {Boolean} \u662F\u5426\u5339\u914D\r\n */\r\nfunction matchType(param, type) {\r\n  if (Array.isArray(type)) {\r\n    for (let i = 0; i < type.length; i++) {\r\n      if (matchType(param, type[i])) return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  if (typeof type !== \"function\") {\r\n    if (\r\n      type === \"*\" && param !== null ||\r\n      type === \"...\" ||\r\n      (type === null && param === null) ||\r\n      type === typeof param\r\n    )\r\n      return true;\r\n    return false;\r\n  }\r\n\r\n  switch (typeof param) {\r\n    case \"function\":\r\n    case \"object\":\r\n      break;\r\n    default:\r\n      param = Object(param);\r\n      break;\r\n  }\r\n\r\n  if (param instanceof type || param === type) return true;\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * \u83B7\u53D6\u7C7B\u578B\u540D\u79F0\r\n * @param {any} param - \u4F20\u5165\u7684\u53C2\u6570\r\n * @returns {String} \u7C7B\u578B\u540D\u79F0\r\n */\r\nfunction getTypeName(param) {\r\n  if (param === null) return \"null\";\r\n\r\n  if (param === \"*\") return \"(any)\";\r\n\r\n  const paramType = typeof param;\r\n\r\n  if (paramType in TYPE_NAMES) return TYPE_NAMES.get(paramType);\r\n\r\n  const className = param.name || param.constructor.name;\r\n\r\n  if (paramType === \"function\" && className === \"anonymous\")\r\n    return \"(anonymous)\";\r\n\r\n  return className;\r\n}\r\n\r\n/**\r\n * \u8FD4\u56DE\u4E00\u4E2A\u91CD\u8F7D\u51FD\u6570\r\n * @param {Array<any>} [defaultTypes] - \u9ED8\u8BA4\u53C2\u6570\u7C7B\u578B\u5217\u8868\r\n * @param {Function} [defaultFn] - \u9ED8\u8BA4\u8981\u8C03\u7528\u7684\u51FD\u6570\r\n * @returns {Function} \u91CD\u8F7D\u51FD\u6570\r\n */\r\nexport default function (defaultTypes, defaultFn) {\r\n  const TABLE = new Map();\r\n  let anyFn = null;\r\n\r\n  /**\r\n   * \u8C03\u7528\u515C\u5E95\u51FD\u6570\r\n   * @param  {...any} args - \u53C2\u6570\u5217\u8868\r\n   * @returns {any} \u8FD4\u56DE\u503C\r\n   */\r\n  function runAny(...args) {\r\n    if (anyFn) return anyFn.apply(this, args);\r\n\r\n    throwStackInfo(new Error(), args);\r\n  }\r\n\r\n  /**\r\n   * \u629B\u51FA\u5806\u6808\u4FE1\u606F\r\n   * @param {Error} err - \u9519\u8BEF\u5BF9\u8C61\r\n   * @param {...any} args - \u53C2\u6570\u5217\u8868\r\n   * @throws {Error}\r\n   */\r\n  function throwStackInfo(err, args) {\r\n    const stackList = err.stack.split(\"\\n\").splice(3);\r\n    let errorMessage = \"\";\r\n    let formattedStack = \"\\n\";\r\n    let errorMethodName = \"\";\r\n\r\n    stackList.forEach((stackLine, index, arr) => {\r\n      const parts = stackLine.trim().split(\" \");\r\n      const fullMethodName = parts.length === 3 ? parts[1] : \"(anonymous)\";\r\n      const methodName = fullMethodName.split(\".\").pop();\r\n\r\n      arr[index] = {\r\n        fullMethodName,\r\n        methodName,\r\n        link: parts.length === 3 ? parts[2] : parts[1],\r\n      };\r\n\r\n      if (!index) {\r\n        errorMethodName = methodName;\r\n      } else {\r\n        formattedStack += `${methodName}\\t${arr[index].link}\\n`;\r\n      }\r\n    });\r\n\r\n    const matchingTypes = Array.from(TABLE.keys()).find(\r\n      (types) => types.length === args.length\r\n    );\r\n\r\n    if (!matchingTypes) {\r\n      errorMessage += `The function \"${errorMethodName}\" does not have an overload that takes ${args.length} arguments.`;\r\n      errorMessage += formattedStack;\r\n      throw new Error(errorMessage);\r\n    }\r\n\r\n    let hasError = false;\r\n    matchingTypes.forEach((expectedType, i) => {\r\n      if (!matchType(args[i], expectedType)) {\r\n        const expectedTypeNames = Array.isArray(expectedType)\r\n          ? expectedType.map(getTypeName).join(\"\u3001\")\r\n          : getTypeName(expectedType);\r\n\r\n        errorMessage += `${hasError ? \"\\n\" : \"\"}Argument ${i + 1\r\n          }: Cannot convert from \"${getTypeName(\r\n            args[i]\r\n          )}\" to \"${expectedTypeNames}\".`;\r\n        hasError = true;\r\n      }\r\n    });\r\n\r\n    if (hasError) {\r\n      errorMessage = `Error calling function \"${errorMethodName}\"\\n${errorMessage}`;\r\n      errorMessage += formattedStack;\r\n      throw new Error(errorMessage);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * \u91CD\u8F7D\u51FD\u6570\r\n   * @param {...any} params - \u53C2\u6570\u5217\u8868\r\n   * @returns {any} \u8FD4\u56DE\u503C\r\n   */\r\n  function overload(...params) {\r\n    if (!TABLE.size) return runAny.apply(this, params);\r\n\r\n    const SAME_LENGTH_MATCH = Array.from(TABLE.keys()).filter(\r\n      (v) => {\r\n        return v.length === params.length || v[v.length - 1] === \"...\";\r\n      }\r\n    );\r\n\r\n    loop: for (let i = 0; i < SAME_LENGTH_MATCH.length; i++) {\r\n      const types = SAME_LENGTH_MATCH[i];\r\n\r\n      if (typeof types[0] !== \"undefined\" && types[0] !== \"...\" && params.length === 0) {\r\n        continue loop;\r\n      }\r\n\r\n      for (let j = 0; j < params.length; j++) {\r\n        if (!matchType(params[j], types[j] || types[types.length - 1])) continue loop;\r\n      }\r\n\r\n      return TABLE.get(types).apply(this, params);\r\n    }\r\n\r\n    return runAny.apply(this, params);\r\n  }\r\n\r\n  /**\r\n   * \u6DFB\u52A0\u51FD\u6570\u91CD\u8F7D\r\n   * @param {Array} types - \u53C2\u6570\u7C7B\u578B\u5217\u8868\r\n   * @param {Function} fn - \u8981\u8C03\u7528\u7684\u51FD\u6570\r\n   * @returns {Function} \u91CD\u8F7D\u51FD\u6570\r\n   * @throws {TypeError}\r\n   * @throws {Error}\r\n   */\r\n  overload.add = function (types, fn) {\r\n    if (!Array.isArray(types)) throw new TypeError(`\"types\" must be an array.`);\r\n\r\n    if (typeof fn !== \"function\")\r\n      throw new TypeError(`\"fn\" must be a function.`);\r\n\r\n    for (let i = 0; i < types.length; i++) {\r\n      if (types[i] === \"...\" && i !== types.length - 1) {\r\n        throw new Error(`A \"...\" parameter must be the last parameter in a formal parameter list.`);\r\n      }\r\n    }\r\n\r\n    TABLE.size &&\r\n      Array.from(TABLE.keys()).forEach((key) => {\r\n        if (key.length !== types.length) return;\r\n\r\n        for (let i = 0; i < key.length; i++) {\r\n          if (key[i] !== types[i]) return;\r\n        }\r\n\r\n        throw new Error(`Function with the same signature already exists.`);\r\n      });\r\n\r\n    types.forEach((type) => {\r\n      const isArray = Array.isArray(type);\r\n      if (typeof type !== \"function\" && !isArray && type !== \"*\" && type !== \"...\") {\r\n        throw new Error(`The expected type must be Class, Array, \"*\" or the last parameter type can also be \"...\".`);\r\n      }\r\n\r\n      if (isArray) {\r\n        for (let i = 0; i < type.length; i++) {\r\n          if (\r\n            typeof type[i] !== \"function\" &&\r\n            type[i] !== null &&\r\n            type[i] !== \"*\"\r\n          ) {\r\n            throw new Error(\r\n              `The predetermined type enumeration content must be a Class, null or \"*\".`\r\n            );\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    TABLE.set(types, fn);\r\n\r\n    return overload;\r\n  };\r\n\r\n  /**\r\n   * \u8BBE\u7F6E\u515C\u5E95\u51FD\u6570\r\n   * @param {Function} fn - \u515C\u5E95\u51FD\u6570\r\n   * @returns {Function} \u91CD\u8F7D\u51FD\u6570\r\n   * @throws {TypeError}\r\n   * @throws {Error}\r\n   */\r\n  overload.any = function (fn) {\r\n    if (typeof fn !== \"function\")\r\n      throw new TypeError(`\"fn\" must be a function.`);\r\n\r\n    if (anyFn) throw new Error(`\"any\" function is already defined.`);\r\n\r\n    anyFn = fn;\r\n\r\n    return overload;\r\n  };\r\n\r\n  if (Array.isArray(defaultTypes) && typeof defaultFn === \"function\")\r\n    overload.add(defaultTypes, defaultFn);\r\n  else if (defaultTypes || defaultFn)\r\n    throw new TypeError(`\"defaultTypes\" must be an array and \"defaultFn\" must be a function.`);\r\n\r\n  return overload;\r\n}\r\n"],
  "mappings": "AAIA,IAAMA,EAAa,IAAI,IAAI,CACzB,CAAC,SAAU,QAAQ,EACnB,CAAC,SAAU,QAAQ,EACnB,CAAC,UAAW,SAAS,EACrB,CAAC,SAAU,QAAQ,EACnB,CAAC,SAAU,QAAQ,EACnB,CAAC,YAAa,aAAa,CAC7B,CAAC,EAQD,SAASC,EAAUC,EAAOC,EAAM,CAC9B,GAAI,MAAM,QAAQA,CAAI,EAAG,CACvB,QAAS,EAAI,EAAG,EAAIA,EAAK,OAAQ,IAC/B,GAAIF,EAAUC,EAAOC,EAAK,CAAC,CAAC,EAAG,MAAO,GAExC,MAAO,EACT,CAEA,GAAI,OAAOA,GAAS,WAClB,OACEA,IAAS,KAAOD,IAAU,MAC1BC,IAAS,OACRA,IAAS,MAAQD,IAAU,MAC5BC,IAAS,OAAOD,EAMpB,OAAQ,OAAOA,EAAO,CACpB,IAAK,WACL,IAAK,SACH,MACF,QACEA,EAAQ,OAAOA,CAAK,EACpB,KACJ,CAEA,OAAIA,aAAiBC,GAAQD,IAAUC,CAGzC,CAOA,SAASC,EAAYF,EAAO,CAC1B,GAAIA,IAAU,KAAM,MAAO,OAE3B,GAAIA,IAAU,IAAK,MAAO,QAE1B,IAAMG,EAAY,OAAOH,EAEzB,GAAIG,KAAaL,EAAY,OAAOA,EAAW,IAAIK,CAAS,EAE5D,IAAMC,EAAYJ,EAAM,MAAQA,EAAM,YAAY,KAElD,OAAIG,IAAc,YAAcC,IAAc,YACrC,cAEFA,CACT,CAQe,SAARC,EAAkBC,EAAcC,EAAW,CAChD,IAAMC,EAAQ,IAAI,IACdC,EAAQ,KAOZ,SAASC,KAAUC,EAAM,CACvB,GAAIF,EAAO,OAAOA,EAAM,MAAM,KAAME,CAAI,EAExCC,EAAe,IAAI,MAASD,CAAI,CAClC,CAQA,SAASC,EAAeC,EAAKF,EAAM,CACjC,IAAMG,EAAYD,EAAI,MAAM,MAAM;AAAA,CAAI,EAAE,OAAO,CAAC,EAC5CE,EAAe,GACfC,EAAiB;AAAA,EACjBC,EAAkB,GAEtBH,EAAU,QAAQ,CAACI,EAAWC,EAAOC,IAAQ,CAC3C,IAAMC,EAAQH,EAAU,KAAK,EAAE,MAAM,GAAG,EAClCI,EAAiBD,EAAM,SAAW,EAAIA,EAAM,CAAC,EAAI,cACjDE,EAAaD,EAAe,MAAM,GAAG,EAAE,IAAI,EAEjDF,EAAID,CAAK,EAAI,CACX,eAAAG,EACA,WAAAC,EACA,KAAMF,EAAM,SAAW,EAAIA,EAAM,CAAC,EAAIA,EAAM,CAAC,CAC/C,EAEKF,EAGHH,GAAkB,GAAGO,CAAU,IAAKH,EAAID,CAAK,EAAE,IAAI;AAAA,EAFnDF,EAAkBM,CAItB,CAAC,EAED,IAAMC,EAAgB,MAAM,KAAKhB,EAAM,KAAK,CAAC,EAAE,KAC5CiB,GAAUA,EAAM,SAAWd,EAAK,MACnC,EAEA,GAAI,CAACa,EACH,MAAAT,GAAgB,iBAAiBE,CAAe,0CAA0CN,EAAK,MAAM,cACrGI,GAAgBC,EACV,IAAI,MAAMD,CAAY,EAG9B,IAAIW,EAAW,GAef,GAdAF,EAAc,QAAQ,CAACG,EAAcC,IAAM,CACzC,GAAI,CAAC7B,EAAUY,EAAKiB,CAAC,EAAGD,CAAY,EAAG,CACrC,IAAME,EAAoB,MAAM,QAAQF,CAAY,EAChDA,EAAa,IAAIzB,CAAW,EAAE,KAAK,QAAG,EACtCA,EAAYyB,CAAY,EAE5BZ,GAAgB,GAAGW,EAAW;AAAA,EAAO,EAAE,YAAYE,EAAI,CACrD,0BAA0B1B,EACxBS,EAAKiB,CAAC,CACR,CAAC,SAASC,CAAiB,KAC7BH,EAAW,EACb,CACF,CAAC,EAEGA,EACF,MAAAX,EAAe,2BAA2BE,CAAe;AAAA,EAAMF,CAAY,GAC3EA,GAAgBC,EACV,IAAI,MAAMD,CAAY,CAEhC,CAOA,SAASe,KAAYC,EAAQ,CAC3B,GAAI,CAACvB,EAAM,KAAM,OAAOE,EAAO,MAAM,KAAMqB,CAAM,EAEjD,IAAMC,EAAoB,MAAM,KAAKxB,EAAM,KAAK,CAAC,EAAE,OAChDyB,GACQA,EAAE,SAAWF,EAAO,QAAUE,EAAEA,EAAE,OAAS,CAAC,IAAM,KAE7D,EAEAC,EAAM,QAASN,EAAI,EAAGA,EAAII,EAAkB,OAAQJ,IAAK,CACvD,IAAMH,EAAQO,EAAkBJ,CAAC,EAEjC,GAAI,OAAOH,EAAM,CAAC,EAAM,KAAeA,EAAM,CAAC,IAAM,OAASM,EAAO,SAAW,EAC7E,SAASG,EAGX,QAASC,EAAI,EAAGA,EAAIJ,EAAO,OAAQI,IACjC,GAAI,CAACpC,EAAUgC,EAAOI,CAAC,EAAGV,EAAMU,CAAC,GAAKV,EAAMA,EAAM,OAAS,CAAC,CAAC,EAAG,SAASS,EAG3E,OAAO1B,EAAM,IAAIiB,CAAK,EAAE,MAAM,KAAMM,CAAM,CAC5C,CAEA,OAAOrB,EAAO,MAAM,KAAMqB,CAAM,CAClC,CA6EA,GAnEAD,EAAS,IAAM,SAAUL,EAAOW,EAAI,CAClC,GAAI,CAAC,MAAM,QAAQX,CAAK,EAAG,MAAM,IAAI,UAAU,2BAA2B,EAE1E,GAAI,OAAOW,GAAO,WAChB,MAAM,IAAI,UAAU,0BAA0B,EAEhD,QAASR,EAAI,EAAGA,EAAIH,EAAM,OAAQG,IAChC,GAAIH,EAAMG,CAAC,IAAM,OAASA,IAAMH,EAAM,OAAS,EAC7C,MAAM,IAAI,MAAM,0EAA0E,EAI9F,OAAAjB,EAAM,MACJ,MAAM,KAAKA,EAAM,KAAK,CAAC,EAAE,QAAS6B,GAAQ,CACxC,GAAIA,EAAI,SAAWZ,EAAM,OAEzB,SAASG,EAAI,EAAGA,EAAIS,EAAI,OAAQT,IAC9B,GAAIS,EAAIT,CAAC,IAAMH,EAAMG,CAAC,EAAG,OAG3B,MAAM,IAAI,MAAM,kDAAkD,EACpE,CAAC,EAEHH,EAAM,QAASxB,GAAS,CACtB,IAAMqC,EAAU,MAAM,QAAQrC,CAAI,EAClC,GAAI,OAAOA,GAAS,YAAc,CAACqC,GAAWrC,IAAS,KAAOA,IAAS,MACrE,MAAM,IAAI,MAAM,2FAA2F,EAG7G,GAAIqC,GACF,QAASV,EAAI,EAAGA,EAAI3B,EAAK,OAAQ2B,IAC/B,GACE,OAAO3B,EAAK2B,CAAC,GAAM,YACnB3B,EAAK2B,CAAC,IAAM,MACZ3B,EAAK2B,CAAC,IAAM,IAEZ,MAAM,IAAI,MACR,0EACF,EAIR,CAAC,EAEDpB,EAAM,IAAIiB,EAAOW,CAAE,EAEZN,CACT,EASAA,EAAS,IAAM,SAAUM,EAAI,CAC3B,GAAI,OAAOA,GAAO,WAChB,MAAM,IAAI,UAAU,0BAA0B,EAEhD,GAAI3B,EAAO,MAAM,IAAI,MAAM,oCAAoC,EAE/D,OAAAA,EAAQ2B,EAEDN,CACT,EAEI,MAAM,QAAQxB,CAAY,GAAK,OAAOC,GAAc,WACtDuB,EAAS,IAAIxB,EAAcC,CAAS,UAC7BD,GAAgBC,EACvB,MAAM,IAAI,UAAU,qEAAqE,EAE3F,OAAOuB,CACT",
  "names": ["TYPE_NAMES", "matchType", "param", "type", "getTypeName", "paramType", "className", "overload_default", "defaultTypes", "defaultFn", "TABLE", "anyFn", "runAny", "args", "throwStackInfo", "err", "stackList", "errorMessage", "formattedStack", "errorMethodName", "stackLine", "index", "arr", "parts", "fullMethodName", "methodName", "matchingTypes", "types", "hasError", "expectedType", "i", "expectedTypeNames", "overload", "params", "SAME_LENGTH_MATCH", "v", "loop", "j", "fn", "key", "isArray"]
}
